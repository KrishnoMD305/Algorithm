## **What is the KMP Algorithm?**
The Knuth-Morris-Pratt (KMP) algorithm is an efficient string matching algorithm used to find occurrences of a "pattern" string within a "text" string. Unlike the naive approach, which repeatedly compares characters and backtracks unnecessarily, the KMP algorithm avoids redundant comparisons by using a precomputed "Longest Prefix Suffix" (LPS) array.

### **Key Features:**
1. **Time Complexity:** O(n + m), where `n` is the length of the text and `m` is the length of the pattern.
2. **Space Complexity:** O(m), due to the LPS array.
3. **Efficiency:** Eliminates unnecessary comparisons by leveraging the LPS array.

---

## **Algorithm Steps:**
1. **Preprocessing (Building the LPS Array):**
   - The LPS array stores the length of the longest proper prefix of the pattern that is also a suffix for each position in the pattern.
   - This helps determine how much to shift the pattern when a mismatch occurs.

2. **String Matching:**
   - Start comparing characters of the text and pattern from left to right.
   - If a mismatch occurs, use the LPS array to decide the next position to compare, avoiding unnecessary backtracking.

---

## **Pseudocode Summary:**
1. Build the LPS array for the pattern.
2. Use the LPS array to match the pattern with the text:
   - If characters match, move forward.
   - If a mismatch occurs, use the LPS value to adjust the starting point of the next comparison.

---

## **Source Code Implementations**

### **C Implementation**
```c
#include <stdio.h>
#include <string.h>

void computeLPSArray(char* pat, int M, int* lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;

    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(char* pat, char* txt) {
    int M = strlen(pat);
    int N = strlen(txt);

    int lps[M];
    computeLPSArray(pat, M, lps);

    int i = 0, j = 0;
    while (i < N) {
        if (pat[j] == txt[i]) {
            i++;
            j++;
        }

        if (j == M) {
            printf("Pattern found at index %d\n", i - j);
            j = lps[j - 1];
        } else if (i < N && pat[j] != txt[i]) {
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }
}

int main() {
    char txt[] = "ABABDABACDABABCABAB";
    char pat[] = "ABABCABAB";
    KMPSearch(pat, txt);
    return 0;
}
```

---

### **C++ Implementation**
```cpp
#include <iostream>
#include <vector>
using namespace std;

void computeLPSArray(const string& pat, vector<int>& lps) {
    int M = pat.length();
    int len = 0;
    lps[0] = 0;
    int i = 1;

    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(const string& pat, const string& txt) {
    int M = pat.length();
    int N = txt.length();

    vector<int> lps(M, 0);
    computeLPSArray(pat, lps);

    int i = 0, j = 0;
    while (i < N) {
        if (pat[j] == txt[i]) {
            i++;
            j++;
        }

        if (j == M) {
            cout << "Pattern found at index " << i - j << endl;
            j = lps[j - 1];
        } else if (i < N && pat[j] != txt[i]) {
            if (j != 0)
                j = lps[j - 1];
            else
                i++;
        }
    }
}

int main() {
    string txt = "ABABDABACDABABCABAB";
    string pat = "ABABCABAB";
    KMPSearch(pat, txt);
    return 0;
}
```

---

### **Python Implementation**
```python
def compute_lps_array(pat):
    lps = [0] * len(pat)
    length = 0
    i = 1

    while i < len(pat):
        if pat[i] == pat[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(pat, txt):
    M = len(pat)
    N = len(txt)

    lps = compute_lps_array(pat)

    i = 0  # Index for txt
    j = 0  # Index for pat

    while i < N:
        if pat[j] == txt[i]:
            i += 1
            j += 1

        if j == M:
            print(f"Pattern found at index {i - j}")
            j = lps[j - 1]

        elif i < N and pat[j] != txt[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

# Example usage
txt = "ABABDABACDABABCABAB"
pat = "ABABCABAB"
kmp_search(pat, txt)
```

---

## **Key Takeaways**
1. The KMP algorithm is efficient because it avoids unnecessary comparisons by using the LPS array.
2. The LPS array is computed in O(m) time, and the matching process runs in O(n).
3. It is widely used in applications like text editors, search engines, and bioinformatics.

---